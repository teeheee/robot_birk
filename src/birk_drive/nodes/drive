#!/usr/bin/env python

import rospy
import roslib
from std_msgs.msg import Float32, Int32
from geometry_msgs.msg import Twist
from dual_mc33926_rpi import motors, MAX_SPEED

#############################################################
#############################################################
class TwistToMotors():
#############################################################
#############################################################

    #############################################################
    def __init__(self):
    #############################################################
        rospy.init_node("drive")
        nodename = rospy.get_name()
        rospy.loginfo("%s started" % nodename)

        self.w = rospy.get_param("~base_width", 0.2)

        rospy.Subscriber('encoder/setps_left', Int32, self.steps_left_callback)
        rospy.Subscriber('encoder/setps_right', Int32, self.steps_right_callback)
        rospy.Subscriber('cmd_vel', Twist, self.twistCallback)


        print("running")

        self.rate = rospy.get_param("~rate", 50)
        self.timeout_ticks = rospy.get_param("~timeout_ticks", 2)
        self.left = 0
        self.right = 0
        
        motors.motor1.enable()
        motors.motor2.enable()

        motors.motor1.setSpeed(0)
        motors.motor2.setSpeed(0)

    #############################################################
    def spin(self):
    #############################################################

        r = rospy.Rate(self.rate)
        idle = rospy.Rate(10)
        then = rospy.Time.now()
        self.ticks_since_target = self.timeout_ticks

        ###### main loop  ######
        while not rospy.is_shutdown():

            while not rospy.is_shutdown() and self.ticks_since_target < self.timeout_ticks:
                self.spinOnce()
                r.sleep()
            idle.sleep()

    #############################################################
    def spinOnce(self):
    #############################################################

        self.right = 1.0 * self.dx + self.dr * self.w * 2
        self.left = 1.0 * self.dx - self.dr * self.w * 2

        max_speed = 0.5

        if abs(self.left) > max_speed or abs(self.right) > max_speed:
               scale = max_speed/max(abs(self.left),abs(self.right))
               self.left *= scale
               self.right *= scale

        self.left = int(-MAX_SPEED*self.left)
        self.right = int(MAX_SPEED*self.right)

        motors.motor1.setSpeed(self.left)
        motors.motor2.setSpeed(self.right)

        self.ticks_since_target += 1

    #############################################################
    def twistCallback(self,msg):
    #############################################################

        self.ticks_since_target = 0
        self.dx = msg.linear.x
        self.dr = msg.angular.z

    def steps_left_callback(self, msg):
        print("left: %s"%msg.data)

    def steps_right_callback(self, msg):
        print("right: %s"%msg.data)

#############################################################
#############################################################
def main():
    try:
        twistToMotors = TwistToMotors()
        twistToMotors.spin()
    except rospy.ROSInterruptException:
        motors.motor1.setSpeed(0)
        motors.motor2.setSpeed(0)
        motors.disable()
    motors.motor1.setSpeed(0)
    motors.motor2.setSpeed(0)
    motors.disable()


if __name__ == '__main__':
    main()
